[gd_resource type="ShaderMaterial" load_steps=4 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode cull_disabled, ambient_light_disabled, blend_add, shadows_disabled;

uniform vec4 albedo : hint_color; //207ac9
uniform vec4 edge_albedo : hint_color;
uniform float fresnel_power = 15.0;
uniform float edge_intensity = 10.0;
uniform float fill_amount : hint_range(0, 1) = 0.1;

uniform float proximity_crop_distance : hint_range(0, 1) = 0.01;
uniform float proximity_fade_distance : hint_range(0, 1) = 0.05;
uniform float proximity_clamp : hint_range(0, 1, 1) = 1;

uniform float scanline_period = 0.5;
uniform float scanline_width : hint_range(0, 0.49) = 0.1;
uniform float scanline_intensity = 0.35;

uniform float pattern_scroll_speed = 0.025;
uniform vec2 pattern_uv_offset = vec2(6.0, 3.0);
uniform float pattern_scale = 0.1;

uniform sampler2D pattern_texture : hint_albedo;

void vertex() {
	VERTEX += NORMAL * 0.001;
}

void fragment() {
	//Create a fresnel effect from the NORMAL and VIEW vectors.
	float fresnel = pow(1.0 - dot(NORMAL, VIEW), fresnel_power) * edge_intensity;
	
	//Add back transparency in the middle
	fresnel = fresnel + fill_amount;
	
	//Get the raw linear depth from the depth texture into a  [-1, 1] range
	float depth = texture(DEPTH_TEXTURE, SCREEN_UV).r * 2.0 - 1.0;
	//Recreate linear depth of the intersecting geometry using projection matrix, and subtract the vertex of the sphere
	depth = PROJECTION_MATRIX[3][2] / (depth + PROJECTION_MATRIX[2][2]) + VERTEX.z;
	//Intensity intersection effect
	depth = pow(1.0 - clamp(depth, 0, 1), fresnel_power) * edge_intensity;
	
	//Calculate final alpha using fresnel and depth joined together
	fresnel = fresnel + depth;
	
	//Calculate UV scrolling pattern
	float scrolling_time = TIME * pattern_scroll_speed;
	vec4 pattern = vec4(1) - texture(pattern_texture, (UV * pattern_uv_offset / pattern_scale) + vec2(scrolling_time));
	
	//Use pattern to cut holes in alpha
	fresnel *= pattern.r;
	
	float uv_offset = mod(-TIME * scanline_period, 2.0) - 1.0;
	float scanline = smoothstep(0.5 - scanline_width, 0.5, UV.y + uv_offset) * (1.0 - smoothstep(0.5, 0.5 + scanline_width, UV.y + uv_offset)) * pattern.r;
	
	//Apply final color
	//ALBEDO = vec3(0);
	float depth_tex = textureLod(DEPTH_TEXTURE,SCREEN_UV,0.0).r;
	vec4 world_pos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV*2.0-1.0,depth_tex*2.0-1.0,1.0) + vec4(proximity_crop_distance);
	world_pos.xyz/=world_pos.w;
	float step = clamp(smoothstep(world_pos.z+proximity_fade_distance,world_pos.z,VERTEX.z), 0, proximity_clamp);
	
	ALBEDO = albedo.rgb + clamp(step, 0.2, 1.0) * edge_albedo.rbg;
	EMISSION = albedo.rgb + clamp(step, 0.2, 1.0);
	ALPHA = smoothstep(-0.3, 1, fresnel + scanline * scanline_intensity) + clamp(step, 0.05, 1);
}"

[sub_resource type="OpenSimplexNoise" id=2]
octaves = 4
persistence = 1.0
lacunarity = 4.0

[sub_resource type="NoiseTexture" id=3]
seamless = true
noise = SubResource( 2 )

[resource]
shader = SubResource( 1 )
shader_param/albedo = Color( 0.231373, 1, 1, 1 )
shader_param/edge_albedo = Color( 1, 1, 1, 1 )
shader_param/fresnel_power = 8.0
shader_param/edge_intensity = 32.708
shader_param/fill_amount = 0.1
shader_param/proximity_crop_distance = 0.0
shader_param/proximity_fade_distance = 0.0
shader_param/proximity_clamp = 1.0
shader_param/scanline_period = 0.5
shader_param/scanline_width = 0.333
shader_param/scanline_intensity = 0.35
shader_param/pattern_scroll_speed = 0.025
shader_param/pattern_uv_offset = Vector2( 1, 1 )
shader_param/pattern_scale = 0.4
shader_param/pattern_texture = SubResource( 3 )
